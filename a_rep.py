# -*- coding: utf-8 -*-
"""A*Rep.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JAMxtwYujleajSFAz_3dZNnKy_l4iX2m

#  A* Search Algorithm (Campus Example)

### What is A* Search?

* A* is a smart pathfinding algorithm used to find the **shortest path** in a weighted graph.
* It uses two values:

  * **g(n):** Actual cost to reach a node from the start.
  * **h(n):** Estimated cost (heuristic) from that node to the goal.
* It combines them:
  [
  f(n) = g(n) + h(n)
  ]
  and always picks the node with the smallest `f(n)` first.

---

### Our Example (Graph of Campuses)

* We have campuses (A–F).
* Each connection has a **distance (km)**.
* The heuristic is an **estimate** of how far each campus is from **Campus F** (the goal).

---

### Code Explanation

1. **Graph:**
   Dictionary storing campuses as keys, and connected campuses with distances as values.

2. **Heuristic:**
   Dictionary storing estimated distance from each campus to the goal (Campus F).

3. **A * Function:**

   * `open_list` → a priority queue (heap) to store nodes by their `f` value.
   * `g_costs` → dictionary storing best known actual cost from start.
   * `closed_set` → stores visited nodes (to avoid loops).
   * While there are nodes to explore:

     * Pick the one with the smallest `f`.
     * If it’s the goal, return the path and cost.
     * Otherwise, expand neighbors and update costs.

4. **Run Example:**

   * Start = Campus A
   * Goal = Campus F
   Errors:
1.Attribute Error:
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)\
/tmp/ipython-input-2816732763.py in <cell line: 0>()\
     51 start_node = "Campus A"\
     52 goal_node = "Campus F"\
---> 53 path, cost = a_star(graph, start_node, goal_node, heuristic)\
     54 print("A* Path:", path)\
     55 print("Total Cost:", cost)\

/tmp/ipython-input-2816732763.py in a_star(graph, start, goal, heuristic)\
     23 def a_star(graph, start, goal, heuristic):\
     24     open_list = []\
---> 25     queue.queuepush(open_list, (heuristic[start], [start]))\
     26     g_costs = {start: 0}\
     27     closed_set = set()

AttributeError: module 'queue' has no attribute 'queuepush'\
when we change the heap to queue we get an error.\
import Queue : Attribute error\
2.Graph value (-): output negative\
3.Heap value(-) : output positive\
4.def() : type error
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)\
/tmp/ipython-input-486877519.py in <cell line: 0>()\
     51 start_node = "Campus A"\
     52 goal_node = "Campus F"\
---> 53 path, cost = a_star(graph, start_node, goal_node, heuristic)\
     54 print("A* Path:", path)\
     55 print("Total Cost:", cost)

TypeError: a_star() takes 0 positional arguments but 4 were given\
5.g-cost= start :-1 output 1 value less bcz start was from -1 not 0\
6.node =goal : output will be the starting point\
7.path [-2] output index error
---------------------------------------------------------------------------
IndexError                                Traceback (most recent call last)\
/tmp/ipython-input-512473678.py in <cell line: 0>()\
     51 start_node = "Campus A"\
     52 goal_node = "Campus F"\
---> 53 path, cost = a_star(graph, start_node, goal_node, heuristic)\
     54 print("A* Path:", path)\
     55 print("Total Cost:", cost)

/tmp/ipython-input-512473678.py in a_star(graph, start, goal, heuristic)\
     29     while open_list:\
     30         f, path = heapq.heappop(open_list)\
---> 31         node = path[-2]\
     32
     33         if node == goal:

IndexError: list index out of range\
8.continue = break same behavior\
9.change set function to sum to get Type error

import : All attributes store in this so we use them by importing. \
heap : min heap used here the minimum value is taken to the top in the root\
Graph :indirected used
"""

import heapq
# import queue
# Weighted graph (distances between campuses in km)
graph = {
    "Campus A": {"Campus B": 5, "Campus C": 9},
    "Campus B": {"Campus A": 5, "Campus D": 3, "Campus E": 7},
    "Campus C": {"Campus A": 9, "Campus F": 4},
    "Campus D": {"Campus B": 3, "Campus E": 2},
    "Campus E": {"Campus B": 7, "Campus D": 2, "Campus F": 6},
    "Campus F": {"Campus C": 4, "Campus E": 6}
}

# Heuristic (straight-line estimate from each campus to Campus F as goal)
heuristic = {
    "Campus A": 10,
    "Campus B": 7,
    "Campus C": 4,
    "Campus D": 6,
    "Campus E": 2,
    "Campus F": 0
}

def a_star(graph, start, goal, heuristic):
    open_list = []
    heapq.heappush(open_list, (heuristic[start], [start]))
    g_costs = {start: 0}
    closed_set = set()

    while open_list:
        f, path = heapq.heappop(open_list)
        node = path[-1]

        if node == goal:
            return path, g_costs[node]

        if node in closed_set:
            continue
        closed_set.add(node)

        for neighbor, cost in graph[node].items():
            tentative_g = g_costs[node] + cost
            if neighbor not in g_costs or tentative_g < g_costs[neighbor]:
                g_costs[neighbor] = tentative_g
                f_cost = tentative_g + heuristic.get(neighbor, float('inf'))
                new_path = path + [neighbor]
                heapq.heappush(open_list, (f_cost, new_path))

    return None, float('inf')

# Example run
start_node = "Campus A"
goal_node = "Campus F"
path, cost = a_star(graph, start_node, goal_node, heuristic)
print("A* Path:", path)
print("Total Cost:", cost)